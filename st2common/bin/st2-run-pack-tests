#!/usr/bin/env bash
# Licensed to the StackStorm, Inc ('StackStorm') under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Script which prepares the environment and runs tests for a particular pack
# Note: This script will create a new temporary virtual environment for each
# run by default. If you don't want this behavior (e.g. virtual environment
# already exists), you should pass "-x" flag to the script.

##################
# Common functions
##################

function join { local IFS="$1"; shift; echo "$*"; }

###########
# Constants
###########

# A list of dependencies which are installed and available to every pack tests
# Note: Those only need to be installed when running this script standalone outside of StackStorm
# package installation. When using StackStorm package installation, those dependencies are already
# available (they are installed by st2tests package).
PACK_TEST_PYTHON_DEPENDENCIES_NAMES=(
    'mock'
    'unittest2'
    'nose'
    'coverage'
)
PACK_TEST_PYTHON_DEPENDENCIES_VERSIONS=(
    '>=2.0,<2.1'
    '>=1.1.0,<2.0'
    '>=1.3.7'
    ''
)

VIRTUALENVS_DIR="/tmp/st2-pack-tests-virtualenvs"

###########
# Variables
###########

ST2_PIP_OPTIONS=${ST2_PIP_OPTIONS:-"-q"}
CREATE_VIRTUALENV=true
JUST_TESTS=false
VERBOSE=false
ENABLE_COVERAGE=false
ENABLE_TIMING=false

VIRTUALENV_ACTIVATED=false

STACKSTORM_VIRTUALENV_BIN="/opt/stackstorm/st2/bin"
STACKSTORM_VIRTUALENV_PYTHON_BINARY="${STACKSTORM_VIRTUALENV_BIN}/python"

####################
# Script beings here
####################

function usage() {
    echo "Usage: $0  [-c] [-j] [-t] [-v] [-x] -p <path to pack>" >&2
    echo "  -c : Run tests with code coverage reporting enabled" >&2
    echo "  -j : Just run tests. Use previously installed dependencies" >&2
    echo "       and virtualenv if any. For subsequent test runs." >&2
    echo "  -t : Run tests with timing enabled" >&2
    echo "  -v : Verbose mode (log debug messages to stdout)." >&2
    echo "  -x : Do not create virtualenv for test for tests, e.g. when running in existing one." >&2
}

while getopts ":p:xjvct" o; do
    case "${o}" in
        p)
            PACK_PATH=${OPTARG}
            ;;
        x)
            CREATE_VIRTUALENV=false
            ;;
        j)
            JUST_TESTS=true
            ;;
        v)
            VERBOSE=true
            ;;
        c)
            echo "ENABLED COVERAGE"
            ENABLE_COVERAGE=true
            ;;
        t)
            ENABLE_TIMING=true
            ;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            usage
            exit 2
            ;;
        :)
            echo "Option -$OPTARG requires an argument." >&2
            usage
            exit 2
            ;;
    esac
done

function verbose_log() {
    if [ ${VERBOSE} = true ]; then
        echo $@
    fi
}

function activate_virtualenv() {
    # Activate virtualenv for running pack tests
    if [ "${VIRTUALENV_ACTIVATED}" = false ]; then
        echo "Activating virtualenv in ${VIRTUALENV_DIR}..."
        source ${VIRTUALENV_DIR}/bin/activate
        VIRTUALENV_ACTIVATED=true
    fi
}

if [ ! ${PACK_PATH} ]; then
    # Missing required argument
    usage
    exit 2
fi

PACK_PATH=$(readlink -f ${PACK_PATH})
if [ ! ${PACK_PATH} ]; then
    echo "Usage: $0 -p <pack path> [-x]"
    exit 2
fi

if [ ! -d ${PACK_PATH} ]; then
    echo "Invalid pack path: ${PACK_PATH}"
    exit 3
fi

SCRIPT_PATH=$(readlink -f $0)
DIRECTORY_PATH=$(dirname ${SCRIPT_PATH})

PACK_NAME=$(basename ${PACK_PATH})
PACK_TESTS_PATH="${PACK_PATH}/tests/"

SENSORS_PATH="${PACK_PATH}/sensors/"
ACTIONS_PATH="${PACK_PATH}/actions/"
ETC_PATH="${PACK_PATH}/etc/"

# Bail early if no tests are found, this way we don't need to wait for
# environment set up.
if [  ! -d ${PACK_TESTS_PATH} ]; then
    echo "Running tests for pack: ${PACK_NAME}"
    echo "No tests found."
    exit 0
fi

###################
# Environment setup
###################

ST2_REPO_PATH=${ST2_REPO_PATH}

PACK_REQUIREMENTS_FILE="${PACK_PATH}/requirements.txt"
PACK_TESTS_REQUIREMENTS_FILE="${PACK_PATH}/requirements-tests.txt"

echo "Running tests for pack: ${PACK_NAME}"

# Make sure /opt/stackstorm/bin is in PATH (for package installations)
if [ -d "${STACKSTORM_VIRTUALENV_BIN}" ]; then
    verbose_log "Adding ${STACKSTORM_VIRTUALENV_BIN} to \$PATH"
    export PATH="${STACKSTORM_VIRTUALENV_BIN}:${PATH}"
fi

# Create virtualenv (if requested, otherwise just activate it)
VIRTUALENV_DIR="${VIRTUALENVS_DIR}/${PACK_NAME}"

if [ "${CREATE_VIRTUALENV}" = true ]; then
    if [ "${JUST_TESTS}" = false ]; then
        echo "Creating virtualenv in ${VIRTUALENV_DIR}..."
        mkdir -p ${VIRTUALENVS_DIR}
        virtualenv --system-site-packages ${VIRTUALENV_DIR}

        # Activate the virtualenv
        activate_virtualenv

        # Make sure virtualenv is using latest pip version
        ${VIRTUALENV_DIR}/bin/pip install --upgrade pip
    fi

    if [ ! -d "${VIRTUALENV_DIR}" ]; then
        echo "Virtual environment ${VIRTUALENV_DIR} doesn't exist"
        echo "Run this script without the -j flag to create it or run it with -x flag to not use" \
             "a pack specific virtual environment."
        exit 2
    fi

    # Make sure the virtualenv is activated
    activate_virtualenv
fi

# Note: If we are running outside of st2, we need to add all the st2 components
# to PYTHONPATH
if [ ${ST2_REPO_PATH} ]; then
    ST2_REPO_PATH=${ST2_REPO_PATH:-/tmp/st2}
    ST2_COMPONENTS=$(find ${ST2_REPO_PATH}/* -maxdepth 0 -name "st2*" -type d)
    PACK_PYTHONPATH="$(join ":" ${ST2_COMPONENTS}):${SENSORS_PATH}:${ACTIONS_PATH}:${ETC_PATH}"
else
    # ST2_REPO_PATH not provided, assume all the st2 component packages are
    # already in PYTHONPATH
    PACK_PYTHONPATH="$(join ":" ${ST2_COMPONENTS}):${SENSORS_PATH}:${ACTIONS_PATH}:${ETC_PATH}"
fi

if [ "${JUST_TESTS}" = false ]; then
    # Install st2 dependencies
    if [ ${ST2_REPO_PATH} ]; then
        echo "Installing dependencies from st2 repository..."
        pip install --cache-dir ${HOME}/.pip-cache -q -r ${ST2_REPO_PATH}/requirements.txt
        pip install --cache-dir ${HOME}/.pip-cache -q -r ${ST2_REPO_PATH}/test-requirements.txt
    fi

    # Install global test dependencies
    INSTALLED_PIP_PACKAGES=$(pip list)

    echo "Installing global pack test dependencies..."
    for((i = 0; i < ${#PACK_TEST_PYTHON_DEPENDENCIES_NAMES[@]}; i++)); do
        DEPENDENCY_NAME="${PACK_TEST_PYTHON_DEPENDENCIES_NAMES[$i]}"
        DEPENDENCY_VERSION="${PACK_TEST_PYTHON_DEPENDENCIES_VERSIONS[$i]}"

        echo ${INSTALLED_PIP_PACKAGES} | grep "${DEPENDENCY_NAME}"  > /dev/null || pip install --cache-dir ${HOME}/.pip-cache ${ST2_PIP_OPTIONS} "${DEPENDENCY_NAME}${DEPENDENCY_VERSION}"
    done

    # Install pack dependencies
    if [ -f ${PACK_REQUIREMENTS_FILE} ]; then
        echo "Installing pack-specific dependencies..."
        pip install --cache-dir ${HOME}/.pip-cache ${ST2_PIP_OPTIONS} -r ${PACK_REQUIREMENTS_FILE}
    fi

    # Install pack test dependencies (if any)
    if [ -f ${PACK_TESTS_REQUIREMENTS_FILE} ]; then
        echo "Installing pack-specific test dependencies..."
        pip install --cache-dir ${HOME}/.pip-cache ${ST2_PIP_OPTIONS} -r ${PACK_TESTS_REQUIREMENTS_FILE}
    fi
fi

# Set PYTHONPATH, make sure it contains st2 components in PYTHONPATH
TESTS_PYTHON_PATH=()

# 1. Add PYTHONPATH from StackStorm packages virtualenv (only applies when running on server when
# StackStorm is installed using packages)
if [ -f "${STACKSTORM_VIRTUALENV_PYTHON_BINARY}" ]; then
    ST2_PYTHONPATH=$(${STACKSTORM_VIRTUALENV_PYTHON_BINARY} -c "import sys;print ':'.join([x for x in sys.path if x.strip()])")
    verbose_log "Adding entries from StackStorm virtualenv to PYTHONPATH: ${ST2_PYTHONPATH}"

    TESTS_PYTHON_PATH+=("${ST2_PYTHONPATH}")
fi

# 2. Add pack actions, sensors and tests directories to PYTHONPATH
TESTS_PYTHON_PATH+=("${PACK_PYTHONPATH}")

# 3. Add any exist PYTHONPATH at the end
if [ ! -z "${PYTHONPATH}" ]; then
    TESTS_PYTHON_PATH+=("${PYTHONPATH}")
fi

TESTS_PYTHON_PATH="$(join ":" ${TESTS_PYTHON_PATH[@]})"

export PYTHONPATH="${TESTS_PYTHON_PATH}"

verbose_log "PYTHONPATH=${PYTHONPATH}"
verbose_log "PATH=${PATH}"
verbose_log "Virtualenv activated=${VIRTUALENV_ACTIVATED}"
verbose_log "Installed Python dependencies:"

if [ ${VERBOSE} = true ]; then
    pip list
fi

echo "Running tests..."
# Note: We run nosetests with "--exe" option so it also runs test files which are executable
# (pack install command automatically makes all the files, including test files executable)
NOSE_OPTS=(-s -v --exe --rednose --immediate)

# Should we pass in arguments to enable test coverage
if [ "${ENABLE_COVERAGE}" = true ]; then
  verbose_log "Enabling nosetests coverage"

  # base options to enable test coverage printouts
  NOSE_OPTS+=(--with-coverage --cover-html)

  # Now, by default nosetests prints out test coverage for every module found
  # in the $PYTHONPATH... as you can imagine this is not ideal and may contain
  # a LOT of files. To only print out the modules that we care about we need to
  # specify them on the cdmline using --cover-package=package.name

  # There are two directories that way contain python files
  PACK_PYTHON_DIRS=("${PACK_PATH}/actions/" "${PACK_PATH}/sensors/")

  # There are two scenarios for python files in the PACK_PYTHON_DIRS
  # 1) there are xxx.py files in the root of the directory (ex: actions/example.py)
  # 2) there are sub directories that contain __init__.py files that signify
  #    to python that they're a module (ex: actions/lib/__init.py). All files
  #    within this sub directory will be checked for coverage if we
  #    specify the option for the base module (ex: --cover-package=lib)

  # for each of the directories in the pack that may contain python files
  for pack_python_dir in ${PACK_PYTHON_DIRS}; do

    # find all *.py files in the root of the $pack_python_dir
    for py_absolute in $(find $pack_python_dir  -mindepth 1 -maxdepth 1 -name "*.py"); do
      # remove the $pack_python_dir directory from the beginning of $py_absolute
      py_relative=${py_absolute#$pack_python_dir}
      # convert '/'s to '.'s and remove the '.py' at the end
      py_package=$(echo "$py_relative" | sed 's/\//./g' | sed 's/\.py//g')
      # append the name of this package to the nose options
      verbose_log "Enabling nosetests coverage for python package: $py_package"
      NOSE_OPTS+=(--cover-package=$py_package)
    done

    # find all __init__.py files in sub directories of $pack_python_dir
    for init_absolute in $(find $pack_python_dir  -mindepth 2 -name "__init__.py"); do
      # remove the $pack_python_dir directory from the beginning of $py_absolute
      init_relative=${init_absolute#$pack_python_dir}
      # remove the filename from $init_relative so we're just left with the
      # directory path (this is the name of the package :) ) and then
      # convert '/'s to '.'s
      init_package=$(dirname $init_relative | sed 's/\//./g')
      # append the name of this package to the nose options
      verbose_log "Enabling nosetests coverage for python package: $init_package"
      NOSE_OPTS+=(--cover-package=$init_package)
    done
  done # end for each $PACK_PYTHON_DIR
fi # end enable test coverage

# Should we pass in arguments to enable test timing
if [ "${ENABLE_TIMING}" = true ]; then
  verbose_log "Enabling nosetests timings"
  NOSE_OPTS+=(--with-timer)
fi

nosetests ${NOSE_OPTS[@]} ${PACK_TESTS_PATH}
TESTS_EXIT_CODE=$?

# Clean up and unset the variables
if [ ${VIRTUALENV_ACTIVATED} = true ]; then
    verbose_log "Deactivating virtualenv ${VIRTUALENVS_DIR}"
    deactivate
fi

unset PYTHONPATH
unset PATH

# Exit
exit ${TESTS_EXIT_CODE}
